// Recursive appraoch for the same problem.

class Solution {
public:
    ListNode* removeNodes(ListNode* head) {
        if(!head || !head->next) return head ;               // Base Conditions.

       head->next = removeNodes(head->next) ;                // Reach to the second last node of the list.

       return (head->val < head->next->val) ? head->next : head ;   //  If head value is greater then this linked list of head and other nodes will be returned
                                                                        else the head->next value i.e list of nodes other than current head will be returned.
    }
};

*/ Using the recursive appraoch we recursively traverse to the end of the linked list.
The last node will always be included in the result.

Now the current head will be at second last node. So we compare the value of the head and head->next, 
(i)-If the value is smaller then that means this head can't be included, so we return head->next i.e next node to the previous recursive call.
(ii)-If the value is greater then that means this head must be included so we return head.

Also since we only need to consider the node to the right from head so we store the coming result in the head->variable.
This creates a link to the returned node.
/*
